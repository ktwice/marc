/*	mrc.prgstatic aMarker:={{"ДлинаЗаписи",5,1},;  calculated{"СтатусЗаписи",1,6},;                  n{"ТипЗаписи",1,7},;                     a{"БиблиографическийУровень",1,8},;      m{"НеопределенныеПозицииСимволов",2,9},; 00{"СчетИндикаторов",1,11},;              2{"СчетКодаПодполя",1,12},;              2{"БазовыйАдресДанных",5,13},;           calculated{"УровеньКодирования",1,18},;           <space>{"ФормаОписательнойКаталогизации",1,19},;   i{"ТребованияСвязаннойЗаписи",1,20},;        <space>{"ПланСправочника",4,21}}               450<space>*/package marc;import java.io.*;import java.nio.*;import java.nio.charset.*;import java.util.*;/** * работа с буфером записи в библиотечном формате * @author marina */public class MrcBuff {    public static final String[] attrLeader = {"длина-записи 5","статус-записи 1","тип-записи 1","библиографический-уровень 1","неопределенные-позиции-символов 2","счет-индикаторов 1","счет-кода-подполя 1","базовый-адрес-данных 5","уровень-кодирования 1","форма-описательной-каталогизации 1","требования-связанной-записи 1","план-справочника 4"};    private static final int looktag = 3;    private static final int markersize = 24;    private static final byte recDelimiterByte = 0x1d;    private static final byte fldDelimiterByte = 0x1e;    private static final byte subDelimiterByte = 0x1f;    private int looksize;    private int lookpos;    private int lookstep;    private int base;    private Charset charset;    private byte[] bytes;    private List<Integer>[] maps;    //    int fcount;    private List<List<Integer>> fieldMaps;//    private Melody melody;        private final Counter2 c1 = new Counter2();    private final Counter2 c2 = new Counter2();/** * положить расшифровку Лидера * @param x  */        public void mrcLeader(XLines x) {        for(String s:attrLeader)            x.newline().xml("leader", XLines.attr("size", s.substring(s.length()-1)),s.substring(0,s.length()-2));    }    public void setCharset(Charset charset) {this.charset = charset;}    public String getSimpleMarker() {return "00000nam  2200000   450 ";}    public String getMarker() {return new String(bytes,0,markersize);}    public Charset getCharset() {return charset;}/** * первый элемент - всегда первый байт индикатора * последний элемент - всегда байт разделитель полей * все средние - байт подполя * @param look смещение справочника * @return смещение элемента справочника поля * затем смещение первого байта индикатора в буфере записи, * затем смещения всех разделителей подполей * и наконец последний - смещение разделителя полей. * Все смещения кроме первого показывают внутрь области поля по справочнику. * Область поля имеет размер из справочника, * начинается с позиции из справочника в блоке данных переменной длины и содержит: * -данные поля  * -разделитель полей * -возможно байты выравнивания */        private List<Integer> fmap2(int look) {        List<Integer> fm = new ArrayList<>();        fm.add(look); // справочник        final int pos = base+Field.bytes2int(bytes,look+looktag+looksize,lookpos);        fm.add(pos); // первый байт поля//        final int next = pos+Field.bytes2int(bytes,look+looktag,looksize); // первый байт после поля        int off=pos;        while(bytes[off]!=fldDelimiterByte) {            if(bytes[off]==subDelimiterByte) {                fm.add(off);  // разделитель подполей//                if((int)bytes[off+1] < 32)//                    c1.inc("fmap2() метка подполя непечатный символ");//                if((int)bytes[off+1] < 32 || (int)bytes[off+1] > 127)//                    c1.inc("fmap2() метка подполя не 7-битный ascii символ");            }            ++off;        }        fm.add(off); // разделитель полей//        if(off>=next) c1.inc("fmap() "+((off==next)?"border":"out of")+" look-zone");//        if(fm.size() == 2) {//            if(bytes[look]==(byte)'0' && bytes[look+1]==(byte)'0')//                c1.inc("fmap() subfields in "+(char)bytes[look+2]);//            // дополнительная проверка на крышки в индикаторе        ////            while(--off >= pos)////                if(bytes[off]==(byte)'^') ////                    fm.add(1,off);//        }        return fm;    }/** * инициализация нового буфера * @param bytes буфер * @return Melody best Charset or null */    public Charset wrap(byte[] bytes) {        c1.clear();        this.bytes = bytes;        looksize = bytes[20] - '0';        lookpos = bytes[21] - '0';        lookstep = looktag + looksize + lookpos;        base = Field.bytes2int(bytes, 12, 5);        maps = new List[(base - markersize) / lookstep];        int look = markersize;        int fno = 0;        while(bytes[look] != fldDelimiterByte) {            maps[fno] = fmap2(look);            ++fno;            look += lookstep;        }        if(maps.length != fno) {            maps = Arrays.copyOf(maps, fno);            c1.inc("wrap() fcount recalc");        }        c2.sum(c1);        if(charset != null) return null;        return (charset = melody(new Melody()));    }/**     * Собрать блок данных поля * @param fs (tag, indicator, [sub1, sub2, ...]) * @param charsetout * @return true byte-buffer блока данных поля с разделителем полей в конце */    private static byte[] fsBytes(List<String> fs, Charset charsetout) throws IOException, Exception {        ByteArrayOutputStream bout = new ByteArrayOutputStream();        byte[] b = fs.get(1).getBytes(charsetout);        for(byte b1:b)            if(b1>=0 && b1<32)                throw new Exception("fsBytes() error spec-symbol in field-indicator");        bout.write(b); // indicator        for(String s:fs.subList(2, fs.size())) {            if(s.charAt(0) >= 128)                throw new Exception("fsBytes() error non-7-bit-ascii-symbol in sub-symbol");            b = s.getBytes(charsetout);            for(byte b1:b)                if(b1>=0 && b1<32)                    throw new Exception("fsBytes() error spec-symbol in sub-field");            bout.write(subDelimiterByte);             bout.write(b); // sub-field        }        bout.write(fldDelimiterByte);         return bout.toByteArray();    }/** * Собрать запись. fss сортируется. * @param m маркер * @param fss содержание полей. Подвергается сортировке. * @param charsetout кодировка выходного файла * @return Составляющие запись байт-блоки с разделителем записей в конце */    public static byte[][] fssBytes(String m            , List<List<String>> fss            , final Charset charsetout) throws Exception {        final int looksize = 4;        final int lookpos = 5;        final int lookstep = looktag + looksize + lookpos;        final int fc = fss.size();        byte[] blook = new byte[lookstep];        byte[] bm = m.getBytes(charsetout);        if(bm.length != markersize)            throw new Exception("fssBytes() marker.length != markersize");        if(bm[10] != (byte)'2'         && bm[11] != (byte)'2'        && bm[20] != (byte)('0'+looksize)        && bm[21] != (byte)('0'+lookpos)            )throw new Exception("fssBytes() marker.digits 22 45 faulure");        ByteArrayOutputStream lookout = new ByteArrayOutputStream(fc * lookstep + 1);        ByteArrayOutputStream dataout = new ByteArrayOutputStream();        sortFss(fss);        for(List<String> fs:fss) {            int itag = Integer.valueOf(fs.get(0));            if(itag<1 || itag>999)                throw new Exception("fssBytes() fault tag="+fs.get(0));            byte[] bf = fsBytes(fs, charsetout);            Field.int2bytes(itag, blook, 0, looktag);            Field.int2bytes(bf.length, blook, looktag, looksize);            Field.int2bytes(dataout.size(), blook, looktag+looksize, lookpos);            lookout.write(blook);            dataout.write(bf);        }        lookout.write((int)fldDelimiterByte);        dataout.write((int)recDelimiterByte);        int ibase = bm.length + lookout.size(); // базовый адрес        Field.int2bytes(ibase, bm, 12, 5);        Field.int2bytes(ibase + dataout.size(), bm, 0, 5); // длина записи        return new byte[][] {bm, lookout.toByteArray(), dataout.toByteArray()};    }/** * сложить запись в указанный XLines * @param x * @return XLines с записью в конце * @throws IOException  */        public XLines xml(XLines x) throws IOException {        return xml(x,null);    }    public XLines xml(XLines x, Charset charset) throws IOException {        return xml(x, charset, 0);    }        public XLines xml(XLines x, Charset charset, int no) throws IOException {        String s = charset==null ? "" : XLines.attr("charset", charset.name());        if(no>0) s = s + XLines.attr("r", ""+no);        s = s + XLines.attr("l", getMarker());        x.newline().xml1("r", s);        for(List<String> fs:fss()) {            xml(fs,x);        }        x.xml2("r");        x.write();        return x;    }/** * Комплект Строковых представлений полей * @return fss */        public List<List<String>> fss() {        List<List<String>> fss = new ArrayList<>();        for(List<Integer> fmap:maps)            fss.add(fs(fmap));        return fss;    }    public static void sortFss(List<List<String>> fss) {        fss.sort((x,y)->Integer.compare(Integer.valueOf(x.get(0)),Integer.valueOf(y.get(0))));    }/** * сложить запись во вновь созданный XLines * @return XLines с записью в конце * @throws IOException  */        public XLines xml() throws IOException {        return xml(new XLines());    }/** * сложить указанное поле в указанный XLines * @param index индекс поля * @param x  */        public void xml(List<String> fs, XLines x) {        x.newline().xml1("f","f",fs.get(0));        x.xml("s", fs.get(1));        for(String s:fs.subList(2, fs.size())) {            x.xml("s", XLines.attr("s",s.substring(0, 1)), s.substring(1));        }        x.xml2("f");    }/** * Строковое представление поля (tag,indicator,subfields...) * @param fmap карта поля * @return fs Строковое содержание поля */        private List<String> fs(List<Integer> fmap) {        List<String> fs = new ArrayList<>(fmap.size()-1);        Iterator<Integer> it = fmap.iterator();        fs.add(new String(bytes,it.next(),looktag));        int i = it.next();        int i0 = it.next();        fs.add(new String(bytes,i,i0-i,charset));        while(it.hasNext()) {            i = it.next();            fs.add(new String(bytes, ++i0, i-i0, charset));            i0 = i;        }        return fs;    }// ****************************************************************************    /** * инициализация нового буфера * @param bytes буфер *///    private void fwrap(byte[] bytes) {//        wrap(bytes);//        int fieldcount=fcount;//        while(--fieldcount>=0)//            fieldMaps.add(null);//    }/** * инициализация нового буфера * @param bytes буфер * @param charset непустой чарсет *///    private void wrap(byte[] bytes, Charset charset) {//        fwrap(bytes);//        this.charset = charset;//    }/** * инициализация нового буфера * @param bytes буфер * @param melody автоопределитель чарсета * @return автоопределенный чарсет *///    private Charset wrap(byte[] bytes, Melody melody) {//        fwrap(bytes);//        Charset ch = melodyCharset(melody,95);//        this.charset = (ch==null) ? Charset.defaultCharset() : ch;//        return ch;//    }    public int getFieldsCount() {return fieldMaps.size();}    public String getFieldTag(int index) {        return new String(bytes,markersize+index*lookstep,looktag);    }    public String getFieldTag0(int index) {        int original = markersize+index*lookstep;        byte[] bs = Arrays.copyOfRange(bytes,original-1,original+looktag);        bs[0] = 0x00;        return new String(bs);    }    private List<Integer> getFieldMap(int index) {        List<Integer> map = fieldMaps.get(index);        if(map!=null) return map;        int pos = markersize+index*lookstep+looktag; // size в справочнике        int size = Field.bytes2int(bytes,pos,looksize); // читаем его        pos = base+Field.bytes2int(bytes,pos+looksize,lookpos)-1; // первый байт поля        size+=pos; // последний байт поля        map = new ArrayList<>();        map.add(pos-1); // записываем разделитель полей        while(++pos<size) // конец поля ?            if(bytes[pos]==0x1f) {// конец подполя ?                map.add(pos++); // записываем разделитель подполей/*                int b = bytes[pos]; // метка поля                if (b>='A' && b<='Z') {                    bytes[pos] = (byte)('a'-'A'+b);                    System.out.print("\n**** subfield label("+b+") is non-lowerCase");                }                else if (b>=0x80)                    System.out.print("\n**** subfield label("+b+") is non-ASCII");*/                                }        map.add(size); // записываем следующий разделитель полей        fieldMaps.set(index, map);        return map;    }    private List<Integer> getMap(int index) {        List<Integer> map = maps[index];        if(map==null) {            map = map(index);            maps[index] = map;        }        return map;    }/** * посчитать мелодичность указанного поля * @param index индекс поля * @param m Melody  */        private void melody(List<Integer> fmap, Melody m) {        Iterator<Integer> it = fmap.iterator();        it.next(); // пропускаем справочник        int i = it.next();        int i0 = it.next();        m.test(bytes,i,i0-i);        while(it.hasNext()) {            i = it.next();            ++i0;            m.test(bytes, ++i0, i-i0);            i0 = i;        }    }/** * сложить указанное поле в указанный XLines * @param index индекс поля * @param x  */        public void xml2(int index, XLines x) {        x.newline().xml1("f","f",getFieldTag(index));        int pos = markersize+index*lookstep+looktag; // size в справочнике        int size = Field.bytes2int(bytes,pos,looksize); // читаем его        pos = base+Field.bytes2int(bytes,pos+looksize,lookpos)-1; // первый байт поля        size+=pos; // последний байт поля        int istart=pos; // записываем разделитель полей        int ifinish=istart;        while(++ifinish<size) // конец поля ?            if(bytes[ifinish]==0x1f) {// конец подполя ?                if(istart==pos) {                    ++istart;                    x.xml("s", new String(bytes,istart,ifinish-istart,charset));                } else {                    ++istart;                    String sattr = XLines.attr("s",new String(bytes,istart,1,charset));                    ++istart;                    x.xml("s", sattr, new String(bytes,istart,ifinish-istart,charset));                }                istart=ifinish;            }        if(istart==pos) {            ++istart;            x.xml("s", new String(bytes,istart,ifinish-istart,charset));        } else {            ++istart;            String sattr = XLines.attr("s",new String(bytes,istart,1,charset));            ++istart;            x.xml("s", sattr, new String(bytes,istart,ifinish-istart,charset));        }        x.xml2("f");    }    public Charset melody(Melody m) {        for(List<Integer> fmap:maps) {            melody(fmap, m);        }        return m.best();    }/** * первый элемент - всегда первый байт индикатора (или -1, если индикатора нет) * последний элемент - всегда показывает третий байт после записи * все средние - это первый байт значения, перед которым стоит код подполя * @param index поле * @return индексы первых байт заначений */        private List<Integer> map(int index) {        int p = markersize+index*lookstep+looktag; // size в справочнике        int s = Field.bytes2int(bytes,p,looksize); // читаем его        final int pos = base+Field.bytes2int(bytes,p+looksize,lookpos)-1; // первый байт поля        int size=pos+s; // последний байт поля        if(bytes[size]!=30) size--;        List<Integer> imap = new ArrayList<>();        imap.add(pos+1); // первый байт индикатора, может разделитель подполей        int i=pos;        while(++i<size) // конец поля ?            if(bytes[i]==0x1f) // конец подполя ?                imap.add(i++); // пропускаем код подполя        if(imap.size() == 1) {// дополнительная проверка на крышки в индикаторе                    i = pos;            while(++i < size)                if(bytes[i]==(byte)'^')                     imap.add(i++);        }        imap.add(size); // первый байт после поля        return imap;    }/**        @param index    @param charset    @return */        public List<String> getField(int index, Charset charset) {        List<String> list = new ArrayList<>();        list.add(getFieldTag0(index));        int prev = 0;        for(int i:getFieldMap(index)) {            if (prev!=0) list.add(new String(bytes,prev,i-prev,charset));            prev = i+1; // пропускаем разделитель - стоим на метке        }        return list;    }    public static List<String> sortedField(List<String> field) {        Comparator comparator = new Comparator() {            public int compare(Object o1, Object o2) {                return ((String)o1).charAt(0)-((String)o2).charAt(0);            }        };        Collections.sort(field, comparator);        return field;    }    public List<List<String>> getFields(){        List<List<String>> fields = new ArrayList<List<String>>();        final int fieldcount = getFieldsCount();        for(int index = 0; index<fieldcount; ++index)            fields.add(getField(index,charset));        return fields;    }    public static List<List<String>> sortedFields(List<List<String>> fields) {        Comparator comparator = new Comparator() {            public int compare(Object o1, Object o2) {                return ((List<String>)o1).get(0).                        compareTo(((List<String>)o2).get(0));            }        };        Collections.sort(fields, comparator);        for(List<String> field:fields)            sortedField(field);        return fields;    }    public static String fieldLine(List<String> field) {        String s = field.get(0).substring(1) + "=" + field.get(1).substring(1);        final int count = field.size();        for (int i=2; i<count; ++i)            s += " $" + field.get(i);        return s + "<end>";    }    public static List<String> fieldLines(List<String> field) {        List<String> lines = new ArrayList<String>();        final int count = field.size();        String s = "";        if(2<count) {            s = field.get(2);            s = " $" + s.substring(0, 1) + "=" + s.substring(1);        }        s = field.get(0).substring(1) + "=" + field.get(1).substring(1) + s;        lines.add(s + "<end>");        for (int i=3; i<count; ++i) {            s = field.get(i);            s = " $" + s.substring(0, 1) + "=" + s.substring(1);            lines.add(s + "<end>");        }        return lines;    }    public static List<String> fieldLinesX(List<String> field) {        List<String> lines = new ArrayList<String>();        lines.add(field.get(0).substring(1) + "=" + field.get(1).substring(1) + "<end>");        final int count = field.size();        for (int i=2; i<count; ++i) {            String s = field.get(i);            lines.add(" $" + s.substring(0, 1) + "=" + s.substring(1) + "<end>");        }        return lines;    }    public List<String> text(String prefix) {        List<String> lines = new ArrayList<String>();        lines.add(prefix+"marker="+getMarker()+"<end>");        for(List<String> field:getFields())            lines.add(fieldLine(field));        return lines;    }    public List<String> texts(String prefix) {        List<String> lines = new ArrayList<String>();        lines.add(prefix+"marker="+getMarker()+"<end>");        for(List<String> field:getFields())            lines.addAll(fieldLines(field));        return lines;    }    public List<String> sortedText(String prefix) {        List<String> lines = new ArrayList<String>();        lines.add(prefix+"Marker="+getMarker()+"<end>");        for(List<String> field:sortedFields(getFields()))            lines.add(fieldLine(sortedField(field)));        return lines;    }    public List<String> sortedTexts(String prefix) {        List<String> lines = new ArrayList<String>();        lines.add(prefix+"Marker="+getMarker()+"<end>");        for(List<String> field:sortedFields(getFields()))            lines.addAll(fieldLines(sortedField(field)));        return lines;    }    public Charset melodyCharset(Melody melody, int nearestMaxPercent) {        final int count = getFieldsCount();        for(int index=0; index<count; ++index)            for (Melody.Entry me:melody.entries.values()){                List<String> field = getField(index,me.getCharset());                me.addMelody(field.get(1));                for (int i=2; i<field.size(); ++i)                    me.addMelody(field.get(i).substring(1));            }        return melody.bestCharset(nearestMaxPercent);    }/*    public void setCharset(Charset ch) {        if (ch==null) ch = Charset.defaultCharset();        charset = ch;    }*/    private Map<Integer,List<Field>> newTags() {        final int nvf = getFieldsCount();        Map<Integer,List<Field>> tags = new TreeMap<Integer,List<Field>>();        for(int index=0; index<nvf; index++) {            int tag = Integer.valueOf(getFieldTag(index));            List<Field> fields = tags.get(tag);            if (fields == null) {                fields = new ArrayList<Field>();                tags.put(tag, fields);            }            Field field = new Field();//            field.lazyInit(this,3*index+1);            fields.add(field);        }        return tags;    }/** * с учетом того что в мрц могут повторяться подполя в рамках одного поля * здесь создается дополнительное поле на каждый уровень повторений * @return */    public Map<Integer,List<Field>> newMRCTags() {        final int nvf = getFieldsCount();        Map<Integer,List<Field>> tags = newMarkerTags();        for(int index=0; index<nvf; index++) {            int tag = Integer.valueOf(getFieldTag(index));            List<Field> fields = tags.get(tag);            if (fields == null) {                fields = new ArrayList<Field>();                tags.put(tag, fields);            }            String s = getString(3*index+1);            do {                Field field = new Field();                StringBuilder sbr = field.setMRCString(s);                fields.add(field);                if (sbr == null) break;                s = sbr.toString();            } while (true);        }        return tags;    }/** * сбросить маркер в выходной tags под номером поля 000 */   private Map<Integer,List<Field>> newMarkerTags() {        Map<Integer,List<Field>> tags = new TreeMap<Integer,List<Field>>();        List<Field> fields = new ArrayList<Field>();        tags.put(0, fields);        Field field = new Field();        field.setString(getMarker());        fields.add(field);        return tags;   }/** * реализация LazyField * @param i - метка поля * @return строковое представление поля */    public String getString(int index) {        StringBuilder sb = new StringBuilder();        int prev = 0;        for(int i:getFieldMap(index)) {            if (prev>0) {                if (sb.length()==0) sb.append("^");                sb.append(new String(bytes,prev,i-prev,charset));            }            prev = i+1; // пропускаем разделитель - стоим на метке        }        return sb.toString();    }//    public static void setSubDelimiterByte(byte b){subDelimiterByte=b;}    private static void write(List<List<String>> fields            ,RandomAccessFile raf, Charset charsetout) throws IOException {        byte[] bmarker = "00000nam  2200000   450 ".getBytes(); // маркер        final int looksize = bmarker[20] - '0';        final int lookpos = bmarker[21] - '0';        final int lookstep = looktag + looksize + lookpos;        final int fieldcount = fields.size();        byte[] blookup = new byte[fieldcount * lookstep]; // справочник        Arrays.fill(blookup, (byte)'0'); // инициализируем справочник ноликами        ByteBuffer bb = ByteBuffer.allocate(4096); // буфер полей        int ilook = 0; // метка справочника        int pos = 0; // метка буфера полей        for(int index=0; index<fieldcount; ++index) {            List<String> field = fields.get(index);//            bb.put((byte)0x1e); // символ разделитель полей            bb.put(field.get(1).getBytes()); // индикаторы            for(int i=2; i<field.size(); ++i) {                bb.put(subDelimiterByte); // символ разделитель подполей                bb.put(field.get(i).getBytes(charsetout)); // подполе            }            byte[] bytes = field.get(0).substring(1).getBytes(charsetout); // тэг поля            int size = bytes.length;            if(size>3 || size==0)                System.out.println("FieldTag is too long or empty= "+field.get(0).substring(1));            ilook += looktag; // позиция к которой слева примыкает тэг поля            System.arraycopy(bytes, 0, blookup, ilook-size, size);            int posnext = bb.position();            ilook += looksize; // позиция к которой слева примыкает длина поля            int2bytes(blookup,ilook,posnext-pos);            ilook += lookpos; // позиция к которой слева примыкает смещение поля            int2bytes(blookup,ilook,pos);            pos = posnext;        }        bb.put((byte)0x1e); // символ разделитель полей        bb.put((byte)0x1d); // символ разделитель записей        pos = bb.position();        final int base = markersize + blookup.length;        int2bytes(bmarker,5,base+pos); // длина записи в маркере        int2bytes(bmarker,17,base+1); // базовый адрес в маркере        raf.write(bmarker);        raf.write(blookup);        raf.write(bb.array(),0,pos);    }    private static List<byte[]> bss(final String sMarker            , final List<List<String>> fss            , final Charset charsetout) {        byte[] bmarker = sMarker.getBytes(); // маркер        final int looksize = bmarker[20] - '0';        final int lookpos = bmarker[21] - '0';        final int lookstep = looktag + looksize + lookpos;        final int fc = fss.size();        final byte[] subDelimiterBytes = new byte[] {subDelimiterByte};        final byte[] fldDelimiterBytes = new byte[] {fldDelimiterByte};        final byte[] recDelimiterBytes = new byte[] {recDelimiterByte};        byte[] blookup = new byte[fc * lookstep]; // справочник        Arrays.fill(blookup, (byte)'0'); // инициализируем справочник ноликами        List<byte[]> bss = new ArrayList<>();        bss.add(bmarker);        bss.add(blookup);        int off = 0;        int ilook = 0; // метка справочника        byte[] bytes;        for(int index=0; index<fc; ++index) {            List<String> f = fss.get(index);            int pos = off;            bss.add(fldDelimiterBytes); // символ разделитель полей            bss.add(bytes = f.get(1).getBytes(charsetout)); // индикаторы            off += 1 + bytes.length;            for(int i=2; i<f.size(); ++i) {                bss.add(subDelimiterBytes); // символ разделитель подполей                bss.add(bytes = f.get(i).getBytes(charsetout)); // подполе                off += 1 + bytes.length;            }            bytes = f.get(0).getBytes(); // тэг поля            int size = bytes.length;            ilook += looktag; // позиция к которой слева примыкает тэг поля            System.arraycopy(bytes, 0, blookup, ilook-size, size);            ilook += looksize; // позиция к которой слева примыкает длина поля            int2bytes(blookup, ilook, off-pos);            ilook += lookpos; // позиция к которой слева примыкает смещение поля            int2bytes(blookup, ilook, pos);        }        bss.add(fldDelimiterBytes); // символ разделитель полей        bss.add(recDelimiterBytes); // символ разделитель записей        off += 2;        int base = markersize + blookup.length;        int2bytes(bmarker, 17, base+1); // базовый адрес в маркере        int2bytes(bmarker, 5, base+off); // длина записи в маркере        return bss;    }/** * форматирует число в буфере * @param bytes буфер * @param pos0 позиция к которой число примыкает слева * @param v форматируемое число */    public static void int2bytes(byte[] bytes, int pos0, int v) {        while (v>0) {            bytes[--pos0] = (byte)('0' + v % 10);            v /= 10;        }    }    }