/*	mrc.prgstatic aMarker:={{"ДлинаЗаписи",5,1},;  calculated{"СтатусЗаписи",1,6},;                  n{"ТипЗаписи",1,7},;                     a{"БиблиографическийУровень",1,8},;      m{"НеопределенныеПозицииСимволов",2,9},; 00{"СчетИндикаторов",1,11},;              2{"СчетКодаПодполя",1,12},;              2{"БазовыйАдресДанных",5,13},;           calculated{"УровеньКодирования",1,18},;           <space>{"ФормаОписательнойКаталогизации",1,19},;   i{"ТребованияСвязаннойЗаписи",1,20},;        <space>{"ПланСправочника",4,21}}               450<space>*/package marc;import java.io.*;import java.nio.*;import java.nio.charset.*;import java.util.*;/** * работа с буфером записи в библиотечном формате * @author marina */public class MRCRec implements LazyField {    public static final String[] attrLeader = {"длина-записи 5","статус-записи 1","тип-записи 1","библиографический-уровень 1","неопределенные-позиции-символов 2","счет-индикаторов 1","счет-кода-подполя 1","базовый-адрес-данных 5","уровень-кодирования 1","форма-описательной-каталогизации 1","требования-связанной-записи 1","план-справочника 4"};    private static final int looktag = 3;    private static final int markersize = 24;    private static final byte recDelimiterByte = 0x1d;    private static final byte fldDelimiterByte = 0x1e;    private static final byte subDelimiterByte = 0x1f;    private int looksize;    private int lookpos;    private int lookstep;    private int base;    int fcount;    private byte[] bytes;    private List<Integer>[] maps;    private List<List<Integer>> fieldMaps;    private Charset charset;//    private Melody melody;/** * положить расшифровку Лидера * @param x  */        public void mrcLeader(XLines x) {        for(String s:attrLeader)            x.newline().xml("leader", XLines.attr("size", s.substring(s.length()-1)),s.substring(0,s.length()-2));    }    public MRCRec(Charset charset) {        this.charset = charset;    }    public void setCharset(Charset charset) {        this.charset = charset;    }    /* public MRCRec(Melody melody) {        this.melody = melody;    }*//** * инициализация нового буфера * @param bytes буфер */    public Charset wrap(byte[] bytes) {        this.bytes = bytes;        looksize = bytes[20] - '0';        lookpos = bytes[21] - '0';        base = Field.bytes2int(bytes,12,5);        lookstep = looktag+looksize+lookpos;        fcount = (base-markersize)/lookstep;        maps = new List[fcount];                if(charset != null) return null;                Melody m = new Melody();        melody(m);        charset = m.best();        return charset;    }/** * инициализация нового буфера * @param bytes буфер */    private void fwrap(byte[] bytes) {        wrap(bytes);        int fieldcount=fcount;        while(--fieldcount>=0)            fieldMaps.add(null);    }/** * инициализация нового буфера * @param bytes буфер * @param charset непустой чарсет */    public void wrap(byte[] bytes, Charset charset) {        fwrap(bytes);        this.charset = charset;    }/** * инициализация нового буфера * @param bytes буфер * @param melody автоопределитель чарсета * @return автоопределенный чарсет */    public Charset wrap(byte[] bytes, Melody melody) {        fwrap(bytes);        Charset ch = melodyCharset(melody,95);        this.charset = (ch==null) ? Charset.defaultCharset() : ch;        return ch;    }    public Charset getCharset() {return charset;}    public int getFieldsCount() {return fieldMaps.size();}    public String getMarker() {return new String(bytes,0,markersize);}    public String getFieldTag(int index) {        return new String(bytes,markersize+index*lookstep,looktag);    }    public String getFieldTag0(int index) {        int original = markersize+index*lookstep;        byte[] bs = Arrays.copyOfRange(bytes,original-1,original+looktag);        bs[0] = 0x00;        return new String(bs);    }    private List<Integer> getFieldMap(int index) {        List<Integer> map = fieldMaps.get(index);        if(map!=null) return map;        int pos = markersize+index*lookstep+looktag; // size в справочнике        int size = Field.bytes2int(bytes,pos,looksize); // читаем его        pos = base+Field.bytes2int(bytes,pos+looksize,lookpos)-1; // первый байт поля        size+=pos; // последний байт поля        map = new ArrayList<>();        map.add(pos-1); // записываем разделитель полей        while(++pos<size) // конец поля ?            if(bytes[pos]==0x1f) {// конец подполя ?                map.add(pos++); // записываем разделитель подполей/*                int b = bytes[pos]; // метка поля                if (b>='A' && b<='Z') {                    bytes[pos] = (byte)('a'-'A'+b);                    System.out.print("\n**** subfield label("+b+") is non-lowerCase");                }                else if (b>=0x80)                    System.out.print("\n**** subfield label("+b+") is non-ASCII");*/                                }        map.add(size); // записываем следующий разделитель полей        fieldMaps.set(index, map);        return map;    }    private List<Integer> getMap(int index) {        List<Integer> map = maps[index];        if(map==null) {            map = map(index);            maps[index] = map;        }        return map;    }/** * сложить запись в указанный XLines * @param x * @return XLines с записью в конце * @throws IOException  */        public XLines xml(XLines x) throws IOException {        return xml(x,null);    }    public XLines xml(XLines x, Charset charset) throws IOException {        String s = charset==null ? "" : XLines.attr("charset", charset.name());        x.newline().xml1("r", s + XLines.attr("l", getMarker()));        for(int index=0; index<fcount; index++) {            xml(index,x);        }        x.xml2("r");        x.write();        return x;    }/** * сложить запись в fss * @return fss */        public List<List<String>> fss() {        List<List<String>> fss = new ArrayList<>();//        fss.add(Arrays.asList(new String[] {"", getMarker()}));        for(int index=0; index<fcount; index++)            fss.add(fs(index));        return fss;    }/** * сложить запись во вновь созданный XLines * @return XLines с записью в конце * @throws IOException  */        public XLines xml() throws IOException {        return xml(new XLines());    }/** * сложить указанное поле в указанный XLines * @param index индекс поля * @param x  */        public void xml(int index, XLines x) {        x.newline().xml1("f","f",getFieldTag(index));        Iterator<Integer> it = getMap(index).iterator();        int i = it.next();        int i0 = it.next();        if(i != i0) x.xml("s", new String(bytes,i,i0-i,charset));        while(it.hasNext()) {            i = it.next();            ++i0;            if(i==i0) continue; // голая крышка            String sattr = XLines.attr("s",new String(bytes, i0, 1, charset));            ++i0;            x.xml("s", sattr, new String(bytes, i0, i-i0, charset));            i0 = i;        }        x.xml2("f");    }/** * сложить поле в fs * @param index индекс поля * @return fs */        public List<String> fs(int index) {        List<String> fs = new ArrayList<>();        fs.add(getFieldTag(index));        Iterator<Integer> it = getMap(index).iterator();        int i = it.next();        int i0 = it.next();        fs.add(new String(bytes,i,i0-i,charset));        while(it.hasNext()) {            i = it.next();            fs.add(new String(bytes, ++i0, i-i0, charset));            i0 = i;        }        return fs;    }/** * посчитать мелодичность указанного поля * @param index индекс поля * @param m Melody  */        public void melody(int index, Melody m) {        Iterator<Integer> it = getMap(index).iterator();        int i = it.next();        int i0 = it.next();        m.test(bytes,i,i0-i);        while(it.hasNext()) {            i = it.next();            ++i0;            m.test(bytes, ++i0, i-i0);            i0 = i;        }    }/** * сложить указанное поле в указанный XLines * @param index индекс поля * @param x  */        public void xml2(int index, XLines x) {        x.newline().xml1("f","f",getFieldTag(index));        int pos = markersize+index*lookstep+looktag; // size в справочнике        int size = Field.bytes2int(bytes,pos,looksize); // читаем его        pos = base+Field.bytes2int(bytes,pos+looksize,lookpos)-1; // первый байт поля        size+=pos; // последний байт поля        int istart=pos; // записываем разделитель полей        int ifinish=istart;        while(++ifinish<size) // конец поля ?            if(bytes[ifinish]==0x1f) {// конец подполя ?                if(istart==pos) {                    ++istart;                    x.xml("s", new String(bytes,istart,ifinish-istart,charset));                } else {                    ++istart;                    String sattr = XLines.attr("s",new String(bytes,istart,1,charset));                    ++istart;                    x.xml("s", sattr, new String(bytes,istart,ifinish-istart,charset));                }                istart=ifinish;            }        if(istart==pos) {            ++istart;            x.xml("s", new String(bytes,istart,ifinish-istart,charset));        } else {            ++istart;            String sattr = XLines.attr("s",new String(bytes,istart,1,charset));            ++istart;            x.xml("s", sattr, new String(bytes,istart,ifinish-istart,charset));        }        x.xml2("f");    }    public void melody(Melody m) {        for(int index=0; index<fcount; index++) {            melody(index, m);        }    }/** * первый элемент - всегда первый байт индикатора (или -1, если индикатора нет) * последний элемент - всегда показывает третий байт после записи * все средние - это первый байт значения, перед которым стоит код подполя * @param index поле * @return индексы первых байт заначений */        private List<Integer> map(int index) {        int p = markersize+index*lookstep+looktag; // size в справочнике        int s = Field.bytes2int(bytes,p,looksize); // читаем его        final int pos = base+Field.bytes2int(bytes,p+looksize,lookpos)-1; // первый байт поля        int size=pos+s; // последний байт поля        if(bytes[size]!=30) size--;        List<Integer> imap = new ArrayList<>();        imap.add(pos+1); // первый байт индикатора, может разделитель подполей        int i=pos;        while(++i<size) // конец поля ?            if(bytes[i]==0x1f) // конец подполя ?                imap.add(i++); // пропускаем код подполя        if(imap.size() == 1) {// дополнительная проверка на крышки в индикаторе                    i = pos;            while(++i < size)                if(bytes[i]==(byte)'^')                     imap.add(i++);        }        imap.add(size); // первый байт после поля        return imap;    }/**        @param index    @param charset    @return */        public List<String> getField(int index, Charset charset) {        List<String> list = new ArrayList<>();        list.add(getFieldTag0(index));        int prev = 0;        for(int i:getFieldMap(index)) {            if (prev!=0) list.add(new String(bytes,prev,i-prev,charset));            prev = i+1; // пропускаем разделитель - стоим на метке        }        return list;    }    public static List<String> sortedField(List<String> field) {        Comparator comparator = new Comparator() {            public int compare(Object o1, Object o2) {                return ((String)o1).charAt(0)-((String)o2).charAt(0);            }        };        Collections.sort(field, comparator);        return field;    }    public List<List<String>> getFields(){        List<List<String>> fields = new ArrayList<List<String>>();        final int fieldcount = getFieldsCount();        for(int index = 0; index<fieldcount; ++index)            fields.add(getField(index,charset));        return fields;    }    public static List<List<String>> sortedFields(List<List<String>> fields) {        Comparator comparator = new Comparator() {            public int compare(Object o1, Object o2) {                return ((List<String>)o1).get(0).                        compareTo(((List<String>)o2).get(0));            }        };        Collections.sort(fields, comparator);        for(List<String> field:fields)            sortedField(field);        return fields;    }    public static String fieldLine(List<String> field) {        String s = field.get(0).substring(1) + "=" + field.get(1).substring(1);        final int count = field.size();        for (int i=2; i<count; ++i)            s += " $" + field.get(i);        return s + "<end>";    }    public static List<String> fieldLines(List<String> field) {        List<String> lines = new ArrayList<String>();        final int count = field.size();        String s = "";        if(2<count) {            s = field.get(2);            s = " $" + s.substring(0, 1) + "=" + s.substring(1);        }        s = field.get(0).substring(1) + "=" + field.get(1).substring(1) + s;        lines.add(s + "<end>");        for (int i=3; i<count; ++i) {            s = field.get(i);            s = " $" + s.substring(0, 1) + "=" + s.substring(1);            lines.add(s + "<end>");        }        return lines;    }    public static List<String> fieldLinesX(List<String> field) {        List<String> lines = new ArrayList<String>();        lines.add(field.get(0).substring(1) + "=" + field.get(1).substring(1) + "<end>");        final int count = field.size();        for (int i=2; i<count; ++i) {            String s = field.get(i);            lines.add(" $" + s.substring(0, 1) + "=" + s.substring(1) + "<end>");        }        return lines;    }    public List<String> text(String prefix) {        List<String> lines = new ArrayList<String>();        lines.add(prefix+"marker="+getMarker()+"<end>");        for(List<String> field:getFields())            lines.add(fieldLine(field));        return lines;    }    public List<String> texts(String prefix) {        List<String> lines = new ArrayList<String>();        lines.add(prefix+"marker="+getMarker()+"<end>");        for(List<String> field:getFields())            lines.addAll(fieldLines(field));        return lines;    }    public List<String> sortedText(String prefix) {        List<String> lines = new ArrayList<String>();        lines.add(prefix+"Marker="+getMarker()+"<end>");        for(List<String> field:sortedFields(getFields()))            lines.add(fieldLine(sortedField(field)));        return lines;    }    public List<String> sortedTexts(String prefix) {        List<String> lines = new ArrayList<String>();        lines.add(prefix+"Marker="+getMarker()+"<end>");        for(List<String> field:sortedFields(getFields()))            lines.addAll(fieldLines(sortedField(field)));        return lines;    }    public Charset melodyCharset(Melody melody, int nearestMaxPercent) {        final int count = getFieldsCount();        for(int index=0; index<count; ++index)            for (Melody.Entry me:melody.entries.values()){                List<String> field = getField(index,me.getCharset());                me.addMelody(field.get(1));                for (int i=2; i<field.size(); ++i)                    me.addMelody(field.get(i).substring(1));            }        return melody.bestCharset(nearestMaxPercent);    }/*    public void setCharset(Charset ch) {        if (ch==null) ch = Charset.defaultCharset();        charset = ch;    }*/    public Map<Integer,List<Field>> newTags() {        final int nvf = getFieldsCount();        Map<Integer,List<Field>> tags = new TreeMap<Integer,List<Field>>();        for(int index=0; index<nvf; index++) {            int tag = Integer.valueOf(getFieldTag(index));            List<Field> fields = tags.get(tag);            if (fields == null) {                fields = new ArrayList<Field>();                tags.put(tag, fields);            }            Field field = new Field();            field.lazyInit(this,3*index+1);            fields.add(field);        }        return tags;    }/** * с учетом того что в мрц могут повторяться подполя в рамках одного поля * здесь создается дополнительное поле на каждый уровень повторений * @return */    public Map<Integer,List<Field>> newMRCTags() {        final int nvf = getFieldsCount();        Map<Integer,List<Field>> tags = newMarkerTags();        for(int index=0; index<nvf; index++) {            int tag = Integer.valueOf(getFieldTag(index));            List<Field> fields = tags.get(tag);            if (fields == null) {                fields = new ArrayList<Field>();                tags.put(tag, fields);            }            String s = getString(3*index+1);            do {                Field field = new Field();                StringBuilder sbr = field.setMRCString(s);                fields.add(field);                if (sbr == null) break;                s = sbr.toString();            } while (true);        }        return tags;    }/** * сбросить маркер в выходной tags под номером поля 000 */   private Map<Integer,List<Field>> newMarkerTags() {        Map<Integer,List<Field>> tags = new TreeMap<Integer,List<Field>>();        List<Field> fields = new ArrayList<Field>();        tags.put(0, fields);        Field field = new Field();        field.setString(getMarker());        fields.add(field);        return tags;   }/** * реализация LazyField * @param i - метка поля * @return строковое представление поля */    public String getString(int index) {        StringBuilder sb = new StringBuilder();        int prev = 0;        for(int i:getFieldMap(index)) {            if (prev>0) {                if (sb.length()==0) sb.append("^");                sb.append(new String(bytes,prev,i-prev,charset));            }            prev = i+1; // пропускаем разделитель - стоим на метке        }        return sb.toString();    }//    public static void setSubDelimiterByte(byte b){subDelimiterByte=b;}    public static void write(List<List<String>> fields            ,RandomAccessFile raf, Charset charsetout) throws IOException {        byte[] bmarker = "00000nam  2200000   450 ".getBytes(); // маркер        final int looksize = bmarker[20] - '0';        final int lookpos = bmarker[21] - '0';        final int lookstep = looktag + looksize + lookpos;        final int fieldcount = fields.size();        byte[] blookup = new byte[fieldcount * lookstep]; // справочник        Arrays.fill(blookup, (byte)'0'); // инициализируем справочник ноликами        ByteBuffer bb = ByteBuffer.allocate(4096); // буфер полей        int ilook = 0; // метка справочника        int pos = 0; // метка буфера полей        for(int index=0; index<fieldcount; ++index) {            List<String> field = fields.get(index);//            bb.put((byte)0x1e); // символ разделитель полей            bb.put(field.get(1).getBytes()); // индикаторы            for(int i=2; i<field.size(); ++i) {                bb.put(subDelimiterByte); // символ разделитель подполей                bb.put(field.get(i).getBytes(charsetout)); // подполе            }            byte[] bytes = field.get(0).substring(1).getBytes(charsetout); // тэг поля            int size = bytes.length;            if(size>3 || size==0)                System.out.println("FieldTag is too long or empty= "+field.get(0).substring(1));            ilook += looktag; // позиция к которой слева примыкает тэг поля            System.arraycopy(bytes, 0, blookup, ilook-size, size);            int posnext = bb.position();            ilook += looksize; // позиция к которой слева примыкает длина поля            int2bytes(blookup,ilook,posnext-pos);            ilook += lookpos; // позиция к которой слева примыкает смещение поля            int2bytes(blookup,ilook,pos);            pos = posnext;        }        bb.put((byte)0x1e); // символ разделитель полей        bb.put((byte)0x1d); // символ разделитель записей        pos = bb.position();        final int base = markersize + blookup.length;        int2bytes(bmarker,5,base+pos); // длина записи в маркере        int2bytes(bmarker,17,base+1); // базовый адрес в маркере        raf.write(bmarker);        raf.write(blookup);        raf.write(bb.array(),0,pos);    }    public static List<byte[]> bss(final String sMarker            , final List<List<String>> fss            , final Charset charsetout) {        byte[] bmarker = sMarker.getBytes(); // маркер        final int looksize = bmarker[20] - '0';        final int lookpos = bmarker[21] - '0';        final int lookstep = looktag + looksize + lookpos;        final int fc = fss.size();        final byte[] subDelimiterBytes = new byte[] {subDelimiterByte};        final byte[] fldDelimiterBytes = new byte[] {fldDelimiterByte};        final byte[] recDelimiterBytes = new byte[] {recDelimiterByte};        byte[] blookup = new byte[fc * lookstep]; // справочник        Arrays.fill(blookup, (byte)'0'); // инициализируем справочник ноликами        List<byte[]> bss = new ArrayList<>();        bss.add(bmarker);        bss.add(blookup);        int off = 0;        int ilook = 0; // метка справочника        byte[] bytes;        for(int index=0; index<fc; ++index) {            List<String> f = fss.get(index);            int pos = off;            bss.add(fldDelimiterBytes); // символ разделитель полей            bss.add(bytes = f.get(1).getBytes(charsetout)); // индикаторы            off += 1 + bytes.length;            for(int i=2; i<f.size(); ++i) {                bss.add(subDelimiterBytes); // символ разделитель подполей                bss.add(bytes = f.get(i).getBytes(charsetout)); // подполе                off += 1 + bytes.length;            }            bytes = f.get(0).getBytes(); // тэг поля            int size = bytes.length;            ilook += looktag; // позиция к которой слева примыкает тэг поля            System.arraycopy(bytes, 0, blookup, ilook-size, size);            ilook += looksize; // позиция к которой слева примыкает длина поля            int2bytes(blookup, ilook, off-pos);            ilook += lookpos; // позиция к которой слева примыкает смещение поля            int2bytes(blookup, ilook, pos);        }        bss.add(fldDelimiterBytes); // символ разделитель полей        bss.add(recDelimiterBytes); // символ разделитель записей        off += 2;        int base = markersize + blookup.length;        int2bytes(bmarker, 17, base+1); // базовый адрес в маркере        int2bytes(bmarker, 5, base+off); // длина записи в маркере        return bss;    }/** * форматирует число в буфере * @param bytes буфер * @param pos0 позиция к которой число примыкает слева * @param v форматируемое число */    public static void int2bytes(byte[] bytes, int pos0, int v) {        while (v>0) {            bytes[--pos0] = (byte)('0' + v % 10);            v /= 10;        }    }}